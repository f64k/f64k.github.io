<!DOCTYPE html>

<html lang="ru" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <title>Загрузка текстур</title>
    <meta name="viewport" content="width=device-width, user-scalable=no" />
    <style>
body { 
	background-color: #999;
    /* overflow: hidden; */
	margin: 0px;
}

#glscreen {
	border: 5px solid darkred;
/*
	width:	50%;
	height:	50%;
*/
}

tr.topped td {
    vertical-align: top;
}

    </style>
</head>
<body>
    <script src="three_js/three.js"></script>
    <script src="three_js/Stats.js"></script>
    <script src="three_js/controls/TrackballControls.js"></script>
    <script src="three_js/controls/OrbitControls.js"></script>
    <script src="three_js/libs/dat.gui.min.js"></script>
    <table>
        <tbody>
            <tr><td></td></tr>
            <tr class="topped">
                <td>
                    <div id="file_chooser">
                        <div>
                            <input type="file" id="inputFiles" multiple="multiple" accept="image/*" />
                        </div>
                        <div>
                            <button id="buttonClear">Очистить (<span id="storeCount">_</span>)</button>
                        </div>
                        <div id="divSavedFilesArray">

                        </div>
                    </div>
                </td>
                <td>
                    <div id="divThreeJs">

                    </div>
                    <!--
                    <hr /><div id="debugInfo1"></div>
                    -->
                    <hr />
                    <canvas id='glTexture1' width="512" height="512"></canvas>
                    <hr />
                    <img src="javascript:void(0);" id="imgPreview1" /> 
                </td>
            </tr>
        </tbody>
    </table>

    

<script id="vertexShader" type="x-shader/x-vertex">// <![CDATA[
    //attribute vec2 a_position;
    varying vec2 vUv;
     
    void main() {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);    
        vUv = uv;
    }
// ]]></script>

<script id="fragmentShader" type="x-shader/x-fragment">// <![CDATA[
    const float PI = 3.141592653589793238;
    varying vec2 vUv;

    const float SOMELARGEFLOAT = 951.135664;

    // https://www.shadertoy.com/view/Xd23Dh - гениальные шумы

    vec3 hash3( vec2 p )
    {
        vec3 q = vec3( dot(p,vec2(127.1,311.7)), 
    				   dot(p,vec2(269.5,183.3)), 
    				   dot(p,vec2(419.2,371.9)) );
    	return fract(sin(q)*43758.5453);
    }

    float iqnoise( in vec2 x, float u, float v )
    {
        vec2 p = floor(x);
        vec2 f = fract(x);
		
	    float k = 1.0+63.0*pow(1.0-v,4.0);
	
	    float va = 0.0;
	    float wt = 0.0;
        for( int j=-2; j<=2; j++ )
        for( int i=-2; i<=2; i++ )
        {
            vec2 g = vec2( float(i),float(j) );
		    vec3 o = hash3( p + g )*vec3(u,u,1.0);
		    vec2 r = g - f + o.xy;
		    float d = dot(r,r);
		    float ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );
		    va += o.z*ww;
		    wt += ww;
        }
	
        return va/wt;
    }

    uniform vec2 mouse;
    uniform float uTime;

    void main() {
        //gl_FragColor = vec4(vUv.x, vUv.y, 0.5, 1.0);
        // трехцветная координатная сетка
        //gl_FragColor = vec4(0.5*smoothstep(0.95,1.,cos(vUv.x*13.0*PI*6.0)), 0.5*smoothstep(0.975,1.,cos(vUv.y*13.0*PI*6.0)), 0.5, 1. );
        // монохромная координатная сетка
        //gl_FragColor = vec4(vec3(0.2 + 0.4*smoothstep(0.95,1.,cos(vUv.x*13.0*PI*6.0)) + 0.4*smoothstep(0.975,1.,cos(vUv.y*13.0*PI*6.0)) ), 1.0);
        
        //gl_FragColor = vec4(vec3(fract(mod(vUv.x*SOMELARGEFLOAT,vUv.y)/mod(SOMELARGEFLOAT * vUv.y, vUv.x))),1.0);

        //gl_FragColor = vec4(hash3(vUv),1.0);
        vec2 p = vec2(smoothstep(-1.0,1.0,sin(cameraPosition)));
        float n = 127.0; // 24.0
        float f = iqnoise(n*vUv, p.x, p.y );
	    gl_FragColor = vec4( f, f, f, 1.0 );
    }
// ]]></script>

</body>

<script type="text/javascript"> // <![CDATA[
    "use strict";
    document.addEventListener("DOMContentLoaded", function () {
        LocalPictures.init();
        ThreeJsControl.init();
        // передаем функцию для изменения текстуры
        LocalPictures.addUpdatePictureCall(ThreeJsControl.setNewTexture);
        // для вывода отладочной инфы
        var debugInfo = document.getElementById("debugInfo1");
        if (debugInfo) {
            ThreeJsControl.setDebugInfoFunction(function (pt) {
                debugInfo.innerText = "uv.x=" + pt.x + " uv.y=" + pt.y;
            });
        }
    });
// ]]></script>

<!-- LocalPictures -->
<script type="text/javascript"> // <![CDATA[
    /// панель с картинками, загруженными в локальное хранилище. с возможностью выбрать активную.
    var LocalPictures = (function () {
        "use strict";

        ///
        var divSavedFilesArray,
            buttonClear,
            inputFiles;

        /// очистка хранилища
        function clearSavedFilesArray() {
            if (localStorage) {
                localStorage.setItem("savedFilesArray", JSON.stringify([]));
                renderSavedFilesArray();
            }
        }

        /// вызывается при событии выбора файлов
        function handleFiles(files) {
            if (self.localStorage) { // тут self это window
                var savedFilesArray = localStorage.getItem("savedFilesArray");
                if (!savedFilesArray) {
                    savedFilesArray = [];
                } else {
                    savedFilesArray = JSON.parse(savedFilesArray);
                }

                var pending = 0;  // How many outstanding operations we have

                Array.prototype.forEach.call(files, function (file, index) {
                    var reader = new FileReader();
                    reader.onloadend = function (e) {
                        if (e.target.result) {
                            var image = new Image();
                            // image.onload =
                            image.addEventListener("load", function () {
                                var fileData = {
                                    name: file.name,
                                    width: image.width,
                                    height: image.height,
                                    type: file.type,
                                    //size: file.size,
                                };
                                fileData.dataURL = e.target.result;
                                var strFileData = JSON.stringify(fileData);
                                if (!savedFilesArray.includes(strFileData)) {
                                    savedFilesArray.push(strFileData);
                                    try {
                                        localStorage.setItem("savedFilesArray", JSON.stringify(savedFilesArray));
                                    } catch (ex) {
                                        alert("перебор: " + file.name);
                                    }
                                } else {
                                    alert("повтор: " + file.name);
                                }
                                --pending;
                                if (pending == 0) {
                                    renderSavedFilesArray();
                                }
                            });
                            image.src = e.target.result;
                        } else {
                            alert("нет reader.result");
                        }
                    }; // reader.onloadend
                    reader.readAsDataURL(file);
                    ++pending;
                });

            } else {
                alert("нет localStorage");
            }
        }

        /// на кнопку в списке картинок
        function button1Clicked(e) {
            if (e.currentTarget) {
                if (e.currentTarget.nodeName && e.currentTarget.nodeName.toUpperCase() == "BUTTON") {
                    if (e.currentTarget.children && e.currentTarget.children.length && e.currentTarget.children.length > 0) {
                        Array.prototype.forEach.call(e.currentTarget.children, function (elem, index) {
                            if (elem.nodeName && elem.nodeName.toUpperCase() == "IMG") {
                                useImage(elem);
                            }
                        });
                    } else {
                    }
                } else {
                }
            } else {
            }
        }


        var imgPreview, useImageFunc;
        ///
        function useImage(image) {
            if (!imgPreview) {
                imgPreview = document.getElementById("imgPreview");
            }
            if (image) {
                var picDataUrl = image.src;
                if (imgPreview) { // фиксированный просмотр картинки
                    imgPreview.src = picDataUrl;
                    imgPreview.title = picDataUrl;
                }
                // один внешний подписчик
                if (useImageFunc && useImageFunc instanceof Function) {
                    useImageFunc(image);
                }
            } else {
                if (imgPreview) { // фиксированный просмотр картинки
                    imgPreview.src = "";
                    imgPreview.title = "";
                }
                // один внешний подписчик
                if (useImageFunc && useImageFunc instanceof Function) { useImageFunc(null); }
            }
        }

        var storeCount;
        /// очищаем и отображаем в div-блоке список запомненных картинок
        function renderSavedFilesArray() {
            if (!divSavedFilesArray) {
                divSavedFilesArray = document.getElementById("divSavedFilesArray");
            }
            if (divSavedFilesArray != undefined) {
                divSavedFilesArray.innerHTML = "";
                if (storeCount) { storeCount.innerText = ""; }
                useImage(null); // очищаем превью
                if (localStorage) {
                    var savedFilesArray = localStorage.getItem("savedFilesArray");
                    if (savedFilesArray) {
                        savedFilesArray = JSON.parse(savedFilesArray);
                        var numFiles = savedFilesArray.length
                        if (!storeCount) { storeCount = document.getElementById("storeCount"); }
                        if (storeCount) { storeCount.innerText = numFiles; }
                        for (var i = 0; i < numFiles; i++) {
                            var objPic = JSON.parse(savedFilesArray[i]);
                            var divPic = document.createElement("div");
                            var button1 = document.createElement("button");
                            button1.setAttribute("style", "width:80px; height:80px;");
                            button1.addEventListener("click", button1Clicked);
                            var img = document.createElement("img");
                            if (objPic.width > objPic.height) {
                                img.setAttribute("width", "40px");
                            } else {
                                img.setAttribute("height", "40px");
                            }
                            img.src = objPic.dataURL;
                            button1.appendChild(img);
                            divPic.appendChild(button1);
                            divSavedFilesArray.appendChild(divPic);
                        };
                    } else {
                        alert("не найден divSavedFilesArray");
                    }
                } else {
                    alert("не найден localStorage");
                }
            }
        }

        return {
            ///
            init: function () {

                inputFiles = document.getElementById("inputFiles");
                if (inputFiles) {
                    inputFiles.addEventListener("change", function (e) {
                        handleFiles(e.target.files);
                    });
                } else { alert("Не найден 'inputFiles'"); }

                buttonClear = document.getElementById("buttonClear");
                if (buttonClear) {
                    buttonClear.addEventListener("click", function (e) {
                        clearSavedFilesArray();
                    });
                } else { alert("Не найден 'buttonClear'"); }

                renderSavedFilesArray();
            },
            /// кустарная реализация подписки на событие
            addUpdatePictureCall: function (usePic) {
                if (usePic) {
                    if (!useImageFunc) {
                        if (usePic instanceof Function) {
                            useImageFunc = usePic;
                        } else { alert("Не функция"); }
                    } else { alert("Повторное присвоение"); }
                } else {
                    useImageFunc = null; // сброс
                }
            }
        }; // return

    })();
// ]]></script>

<!-- 
    примеры:
    https://jsfiddle.net/2pha/njetLLz7/ - текстура из dataUrl
    http://threejs.org/examples/webgl_geometry_terrain_raycast.html - ланшафт с отметкой от указателя
    https://threejsdoc.appspot.com/doc/three.js/examples/misc_camera_roll.html - управление камерой
    http://stemkoski.github.io/Three.js/GUI-Controller.html - gui и базовая сцена

    canvas попиксельно:
    https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas
-->

<!-- ThreeJsControl -->
<script type="text/javascript">    // <![CDATA[
    ///
    var ThreeJsControl = (function () {
        "use strict";

        ///
        var textureLoader,
            container,
            renderer,
            scene,
            camera,
            mesh,
            meshSkyBox,
            controls;

        /// вспомогательные
        var guiObject, stats;
        ///
        var viewWidth, viewHeight;

        /// тут задаем цвет вершин, взяв правые цифры из значений координат, псевдослучайно
        function pseudoRandomVertexColors(p) {
            var retObj = {}, geometry, material;
            // https://stemkoski.github.io/Three.js/Vertex-Colors.html - пример
            var numOfRightDigits = 1, pow10digs = Math.pow(10, numOfRightDigits);
            var radiusOfSphere = Math.sqrt(Math.sqrt(3)); // 1.31607401295 - просто так подобрано, чтобы избежать круглых координат
            radiusOfSphere *= 5000; // превращаем в SkyBox

            if (p) {
                if (p == 1) {
                    geometry = new THREE.SphereGeometry(radiusOfSphere, 127, 127);
                }
            } else {
                geometry = new THREE.IcosahedronGeometry(radiusOfSphere, guiObject.icosahedronLevel);
            }
            
            geometry.vertices.forEach(function (v) {
                // красный из X
                var rc = v.x.toString();
                if (rc.length > 2) { rc = rc.substring(rc.length - numOfRightDigits); }
                rc = rc.split('').reverse().join('');
                // зеленый из Z
                var gc = v.z.toString();
                if (gc.length > 2) { gc = gc.substring(gc.length - numOfRightDigits); }
                gc = gc.split('').reverse().join('');
                // синий из Y
                var bc = v.y.toString();
                if (bc.length > 2) { bc = bc.substring(bc.length - numOfRightDigits); }
                bc = bc.split('').reverse().join('');

                // цвета задаются в интервале 0..1
                var fR = parseInt(rc) / pow10digs, fG = parseInt(gc) / pow10digs, fB = parseInt(bc) / pow10digs;
                var color = new THREE.Color(fR, fG, fB);
                geometry.colors.push(color);
            });
            // faces are indexed using characters
            var face, numberOfSides, vertexIndex, faceIndices = ['a', 'b', 'c', 'd'];
            // copy the colors to corresponding positions in each face's vertexColors array.
            for (var i = 0; i < geometry.faces.length; i++) {
                face = geometry.faces[i];
                numberOfSides = (face instanceof THREE.Face3) ? 3 : 4;
                for (var j = 0; j < numberOfSides; j++) {
                    vertexIndex = face[faceIndices[j]];
                    face.vertexColors[j] = geometry.colors[vertexIndex];
                }
            }
            material = new THREE.MeshPhongMaterial({ vertexColors: THREE.VertexColors });
            //geometry.colorsNeedUpdate = true;
            retObj.material = material;
            retObj.geometry = geometry;
            return retObj;
        }

        ///
        function initMeshes(scene) {
            if (scene && scene instanceof THREE.Scene) {
                var geometry, material;
                var _meshObject;
                if (guiObject && guiObject.generateColors) {
                    var methodType = 1;
                    if (methodType == 1) {
                        // тут задаем цвет вершин, взяв правые цифры из значений координат, псевдослучайно
                        var retObj = pseudoRandomVertexColors();
                        geometry = retObj.geometry;
                        material = retObj.material;
                    }
                    if (methodType == 2) {
                        //geometry = new THREE.IcosahedronGeometry(1, guiObject.icosahedronLevel);
                        //geometry = new THREE.SphereGeometry(1, 130, 130);
                        //geometry = new THREE.SphereGeometry(1, 13, 13);
                        geometry = new THREE.BoxGeometry(10001, 10001, 10001);

                        material = new THREE.ShaderMaterial({
                            vertexShader: document.getElementById('vertexShader').textContent,
                            fragmentShader: document.getElementById('fragmentShader').textContent,
                            //lights: true,
                        });
                    }

                    material.side = THREE.BackSide; //THREE.DoubleSide;
                    meshSkyBox = new THREE.Mesh(geometry, material);
                    scene.add(meshSkyBox);

                } else {
                    if (meshSkyBox) {
                        scene.remove(meshSkyBox);
                        meshSkyBox = null;
                    }
                }

                if (true) {
                    geometry = new THREE.CylinderBufferGeometry(1, 1, 1.6, 60); // Цилиндр
                    //geometry = new THREE.BoxGeometry(1, 1, 1);
                    geometry = new THREE.TorusBufferGeometry(0.7, 0.5, 16, 32);
                    //geometry = new THREE.DodecahedronGeometry(1);
                    geometry = new THREE.SphereGeometry(1, 60, 24);
                    //geometry = new THREE.PlaneGeometry(1, 1, 3, 3);

                    //var material = new THREE.MeshBasicMaterial({ color: 0x404050 }); // { color: 0x606070 }

                    //var material = new THREE.MeshStandardMaterial();
                    //var material = new THREE.MeshStandardMaterial({ color: 0x550000, roughness: 0.1, metalness: 1.0 });

                    //var material = new THREE.MeshPhongMaterial({ color: 0xdddddd, specular: 0x009900, shininess: 30, shading: THREE.FlatShading });

                    material = new THREE.MeshPhongMaterial();
                    //material.opacity = 0.5;
                    material.transparent = true; // для PNG
                    material.side = THREE.DoubleSide;
                    _meshObject = new THREE.Mesh(geometry, material);
                    scene.add(_meshObject);
                }

                return _meshObject;
            } else { alert("параметр не THREE.Scene"); }
        }

        ///
        function initLights(scene) {
            if (scene && scene instanceof THREE.Scene) {
                // Create ambient light and add to scene.
                var light = new THREE.AmbientLight(0x404040); // soft white light
                scene.add(light);

                // Create directional light and add to scene.
                var directionalLight = new THREE.DirectionalLight(0xffffff);
                directionalLight.position.set(1, 1, 1).normalize();
                scene.add(directionalLight);

                return {
                    ambientLight: light,
                    directionalLight: directionalLight,
                }
            } else { alert(""); }
        }

        ///
        function initCamera(fov) {
            var aspect = viewWidth / viewHeight;
            var _camera = new THREE.PerspectiveCamera(fov, aspect, 0.1, 10000);
            _camera.position.z = 2;
            return _camera;
        }

        ///
        function initControls(camera, renderer_domElement) {
            if (camera && camera instanceof THREE.Camera) {
                if (renderer_domElement && renderer_domElement instanceof HTMLElement) {

                    //_controls = new THREE.OrbitControls(camera, _renderer_domElement);
                    var _controls = new THREE.TrackballControls(camera, renderer_domElement);
                    _controls.minDistance = 1.3;
                    _controls.maxDistance = 5;
                    return _controls;
                } else { alert("wrong renderer_domElement object"); }
            } else { alert("wrong camera object"); }
        }

        function initStats(_container) {
            if (_container && _container instanceof HTMLElement) {
                // Add stats to page.
                var _stats = new Stats();
                _stats.domElement.style.position = 'relative';
                //_stats.domElement.style.right = '0px';
                _container.appendChild(_stats.domElement);
                return _stats;
            } else { alert("wrong _container object"); }
        }

        /// вспомогательные объекты сцены
        var wireframe, axes;
        /// форма настраиваемых параметров
        function initDatGui() {
            var ctrlObj = new function () {
                this.yRotationStep = 0.001;
                this.wireframe = false;
                this.generateColors = true;
                this.icosahedronLevel = 5;
            };

            var gui = new dat.GUI();
            gui.add(ctrlObj, "yRotationStep", 0.0, 0.01);
            gui.add(ctrlObj, "wireframe").onChange(function (value) {
                if (value) {
                    if (!wireframe) {
                        wireframe = new THREE.WireframeHelper(mesh, 0x501060);
                        // var edges = new THREE.EdgesHelper(mesh, 0x00ff00); // showing only "hard" edges (edges between non-coplanar faces)
                        scene.add(wireframe);
                        axes = new THREE.AxisHelper(2);
                        scene.add(axes);
                    }
                } else {
                    if (wireframe) {
                        scene.remove(wireframe);
                        wireframe = null;
                    }
                    if (axes) {
                        scene.remove(axes);
                        axes = null;
                    }
                }
            });
            gui.add(ctrlObj, "generateColors").onChange(function (value) {
                if (mesh) {
                    scene.remove(mesh);
                }
                mesh = initMeshes(scene);
            });
            gui.add(ctrlObj, "icosahedronLevel", 0, 7).step(1).onChange(function (value) {
                if (mesh && mesh.geometry instanceof THREE.IcosahedronGeometry) {
                    scene.remove(mesh);
                    mesh = initMeshes(scene);
                }
            });
            gui.closed = true;
            return ctrlObj;
        }

        /// 
        var raycaster, mouse, debugInfoFunc;
        ///
        var canvas2d, context2d, texture;
        ///
        function raycastToTexture() {
            if (raycaster) {
                if (mouse) {
                    // update the picking ray with the camera and mouse position	
                    raycaster.setFromCamera(mouse, camera);
                    // calculate objects intersecting the picking ray
                    var intersects = raycaster.intersectObjects(scene.children);
                    for (var i = 0; i < intersects.length; i++) {
                        var iobj = intersects[i];//.object.material.color.set(0xff0000);
                        if (iobj && iobj.uv) {
                            var vec2UV = iobj.uv;
                            if (debugInfoFunc && debugInfoFunc instanceof Function) {
                                debugInfoFunc(vec2UV);
                            }
                            if (context2d) {
                                var canvX = vec2UV.x * canvas2d.width;
                                var canvY = (1 - vec2UV.y) * canvas2d.height; // в примерах так не переворачивали
                                context2d.beginPath();
                                context2d.arc(canvX, canvY, 2, 0, 2 * Math.PI);
                                context2d.stroke();

                                if (mesh.material.map) {
                                    //mesh.material.map.image = canvas2d;
                                    mesh.material.map.needsUpdate = true;
                                    //mesh.material.needsUpdate = true;
                                }
                            }
                            break; // прерываем цикл
                        }
                    }
                }
            }
        }

        ///
        function render() {
            requestAnimationFrame(render);

            raycastToTexture();

            //mesh.rotation.x += 0.005;
            mesh.rotation.y += guiObject.yRotationStep;

            controls.update();

            renderer.render(scene, camera);
            stats.update();
        }


        return {
            ///
            init: function () {
                textureLoader = new THREE.TextureLoader();
                // графическое пояснение: http://ushiroad.com/3j/
                container = document.getElementById("divThreeJs");
                if (container) {
                    /// пока задано так
                    viewWidth = 640;
                    viewHeight = 480;
                    // задаем вначале. от параметров зависит отрисовка
                    guiObject = initDatGui();

                    renderer = new THREE.WebGLRenderer({ antialias: true }); //renderer = new THREE.CanvasRenderer(); // убран
                    renderer.setSize(viewWidth, viewHeight);
                    container.appendChild(renderer.domElement);

                    scene = new THREE.Scene();
                    initLights(scene);
                    camera = initCamera(30);
                    controls = initControls(camera, renderer.domElement);

                    mesh = initMeshes(scene);

                    // так отображается снизу
                    stats = initStats(container);

                    raycaster = new THREE.Raycaster();
                    renderer.domElement.addEventListener("mousemove", function (event) {
                        if (event.ctrlKey) {
                            var canvasMouseX, canvasMouseY;
                            if (false) {
                                canvasMouseX = event.clientX;
                                canvasMouseY = event.clientY;
                            }
                            else {
                                if (false) {
                                    canvasMouseX = event.layerX;
                                    canvasMouseY = event.layerY;
                                } else {
                                    canvasMouseX = event.offsetX;
                                    canvasMouseY = event.offsetY;
                                }
                            }
                            var norm_x = (canvasMouseX / viewWidth) * 2 - 1;
                            var norm_y = -(canvasMouseY / viewHeight) * 2 + 1;
                            mouse = new THREE.Vector2(norm_x, norm_y);
                            if (debugInfoFunc) {
                                //debugInfo.innerText = "mouse.x=" + mouse.x + " mouse.y=" + mouse.y;
                            }
                        } else {
                            mouse = null;
                        }
                    });

                    render();
                } else { alert("Не найден divThreeJs"); }
                // внешний canvas для текстуры
                canvas2d = document.getElementById("glTexture1");
                if (canvas2d) {
                    context2d = canvas2d.getContext("2d");
                } else { alert("Не найден 'glTexture1'"); }
            },
            /// вызывается объектами снаружи для замены текстуры
            setNewTexture: function (image) {
                if (image && image instanceof HTMLImageElement) {
                    // на canvas
                    if (context2d && context2d instanceof CanvasRenderingContext2D) {
                        context2d.clearRect(0, 0, canvas2d.width, canvas2d.height);
                        context2d.drawImage(image, 0, 0, canvas2d.width, canvas2d.height);
                        // дополнительный рисунок на canvas
                        context2d.beginPath();
                        context2d.arc(canvas2d.width / 2, canvas2d.height / 2, 256 - 2, 0, 2 * Math.PI);
                        context2d.stroke();
                        context2d.beginPath();
                        var dXY = 10;
                        context2d.moveTo(dXY, dXY);
                        context2d.lineTo(canvas2d.width - dXY, canvas2d.height - dXY);
                        context2d.stroke();
                    }

                    var texture;
                    //texture = THREE.ImageUtils.loadTexture(picDataUrl);
                    //texture = textureLoader.load(picDataUrl);
                    texture = new THREE.Texture(canvas2d);
                    texture.needsUpdate = true;

                    if (texture) {
                        //mesh.material.map = texture;
                        mesh.material.setValues({ map: texture });
                        mesh.material.needsUpdate = true;

                        //if (mesh && mesh.material) {
                        // // Create NEW material
                        //var material = new THREE.MeshBasicMaterial({ map: texture });
                        //var material = new THREE.MeshLambertMaterial({ map: texture });
                        //var material = new THREE.MeshPhongMaterial({ map: texture, side: THREE.DoubleSide });
                        //var material = new THREE.MeshStandardMaterial({ map: texture });
                        //var material = new THREE.MeshPhongMaterial({ bumpMap: texture }); // bumpMap normalMap displacementMap
                        //mesh.material = material;
                        //}
                    } else { }
                } else {
                    // на canvas
                    if (context2d && context2d instanceof CanvasRenderingContext2D) {
                        context2d.clearRect(0, 0, canvas2d.width, canvas2d.height);
                    }

                    mesh.material.setValues({ map: null });
                    mesh.material.needsUpdate = true;
                }
            },
            /// передаем div для вывода отладочной информации
            setDebugInfoFunction: function (func) {
                if (func) {
                    debugInfoFunc = func;
                }
            },
        };
    })();


// ]]></script>

<!-- 
    дополнительные примеры:
    https://github.com/spite/THREE.DecalGeometry - пейнтбол на сложном объекте
    http://stackoverflow.com/questions/12438674/three-js-multiple-material-plane - шахматная доска, несколько материалов на одном объекте

    http://stemkoski.github.io/Three.js/ParticleSystem-Shader.html - частицы с помощью шейдера

    http://stemkoski.github.io/Three.js/Skybox.html - SkyBox
    http://stemkoski.github.io/Three.js/Mouse-Click.html - перекрас треугольника мышью
    https://stemkoski.github.io/Three.js/Sphere-Project.html - проекция куба на сферу

    https://www.clicktorelease.com/blog/vertex-displacement-noise-3d-webgl-glsl-three-js - шейдерная текстура


    https://www.shadertoy.com/view/Xd23Dh - шейдер с примером красивых шумов
    https://www.shadertoy.com/view/XsG3Dc - шейдер деревянный паркет
    https://thebookofshaders.com/edit.php#11/wood.frag - пример рисунка древесного спила
    https://thebookofshaders.com/11/ - объяснение по генерируемым текстурам
    https://thebookofshaders.com/09/ - паттерны в шейдере
    https://github.com/ashima/webgl-noise/wiki - ashima примеры
    https://thebookofshaders.com/edit.php#11/2d-gnoise.frag - простой Perlin noise

    просто сборник ссылок по Three.js
    https://github.com/mrdoob/three.js/wiki
-->

<script type="text/javascript">// <![CDATA[

  var gl;
  var canvas;

  var buffer;

  var shaderSource;
  var vertexShader;
  var fragmentShader;

  var program;

  var mouseX, mouseY;
 


	function init() 
	{
	
		viewX = 640.0;
		viewY = 480.0;
		
		canvas        = document.getElementById('glscreen');
		gl            = canvas.getContext('experimental-webgl');
		canvas.width  = 640;
		canvas.height = 480;
		
		canvas.onmousemove = function(evt) {
			evt.preventDefault();
			mouseX = 2*(evt.pageX / viewX) - 1;
			mouseY = 1 - 2*(evt.pageY / viewY);

			//gl.uniform2f(gl.getUniformLocation(program, "mouse"), mouseX, mouseY);
			var touches3arr = new Float32Array(30);
			touches3arr[0] = mouseX;
			touches3arr[1] = mouseY;
			touches3arr[2] = -1;
			gl.uniform1i(gl.getUniformLocation(program, "touches_length"), 1);
			gl.uniform3fv(gl.getUniformLocation(program, "touches"), touches3arr);
		};
		
		canvas.addEventListener('touchstart', function(event) {
			event.preventDefault();
			//console.log('touchstart');
			touches = event.touches;
		});
		
		canvas.addEventListener('touchmove', function(event) {
			event.preventDefault();
			touches = event.touches;
			var touches3arr = new Float32Array(30);
			for(var i=0; i<touches.length; i++)
			{
				touch = touches[i];
				touches3arr[3*i+0] = 2*(touch.pageX / viewX) - 1;
				touches3arr[3*i+1] = 1 - 2*(touch.pageY / viewY);
				touches3arr[3*i+2] = touch.identifier;
			}
			gl.uniform1i(gl.getUniformLocation(program, "touches_length"), touches.length);
			gl.uniform3fv(gl.getUniformLocation(program, "touches"), touches3arr);
		});
		
		canvas.addEventListener('touchend', function() {
			event.preventDefault();
			//console.log('touchend');
			//touches = event.touches;
		});
		

		gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
		
		setup_shaders();

		setup_vertex(); 
		
		render();
	
	}
 
	function render(time) 
	{
		//gl.uniform1f(gl.getUniformLocation(program, "time"), time);
		
		//gl.clearColor(1.0, 1.0, 1.0, 1.0);
		//gl.clear(gl.COLOR_BUFFER_BIT);
		
		gl.drawArrays(gl.TRIANGLES, 0, 6);
		
		window.requestAnimationFrame(render, canvas);
	}
	
	
	//window.onload = init;

// ]]></script>

<script type="text/javascript">// <![CDATA[

	function setup_vertex() 
	{
		buffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
		gl.bufferData(
			gl.ARRAY_BUFFER, 
			new Float32Array([
				-1.0, -1.0, 
				1.0, -1.0, 
				-1.0,  1.0, 
				-1.0,  1.0, 
				1.0, -1.0, 
				1.0,  1.0]), 
			gl.STATIC_DRAW
		);
		
		positionLocation = gl.getAttribLocation(program, "a_position");
		gl.enableVertexAttribArray(positionLocation);

		gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
		
	}

	function setup_shaders()
	{
		shaderScript = document.getElementById("2d-vertex-shader");
		shaderSource = shaderScript.text;
		vertexShader = gl.createShader(gl.VERTEX_SHADER);
		gl.shaderSource(vertexShader, shaderSource);
		gl.compileShader(vertexShader);
		if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
		    alert(gl.getShaderInfoLog(vertexShader));
		}
		
		shaderScript   = document.getElementById("2d-fragment-shader");
		shaderSource   = shaderScript.text;
		fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
		gl.shaderSource(fragmentShader, shaderSource);
		gl.compileShader(fragmentShader);
		if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
		    alert(gl.getShaderInfoLog(fragmentShader));
		}
		
		program = gl.createProgram();
		gl.attachShader(program, vertexShader);
		gl.attachShader(program, fragmentShader);
		gl.linkProgram(program);	
		if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
		    alert("Could not initialise shaders");
		}
		gl.useProgram(program);
	}

// ]]></script>

</html>