<!DOCTYPE html>

<html lang="ru" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <title>WebGL Touch Tracker</title>
    <meta name="viewport" content="width=device-width, user-scalable=no">
    <style>
body { 
	background-color: #999;
    overflow: hidden;
	margin: 0px;
}

#glscreen {
	border: 5px solid darkred;
/*
	width:	50%;
	height:	50%;
*/
}
    </style>
</head>
<body>
    <canvas id='glscreen'></canvas>

<script id="2d-vertex-shader" type="x-shader/x-vertex">// <![CDATA[
  attribute vec2 a_position;
  void main() {
    gl_Position = vec4(a_position, 0, 1); //0. is the z, and 1 is w
  }
// ]]></script>

<script id="2d-fragment-shader" type="x-shader/x-fragment">// <![CDATA[
#ifdef GL_FRAGMENT_PRECISION_HIGH
  precision highp float;
#else
  precision mediump float;
#endif
//uniform float time;
//uniform float fps;
//uniform vec4 rnd;

//uniform vec2 mouse;
uniform vec3 touches[10];
uniform int touches_length;

void main() {
	float fc = 0.2;
	//int tl = touches_length;
	for(int i=0; i<10; i++)
	{
		//int i1 = i;
		if(i<touches_length)
		{
			float nX = (gl_FragCoord.x - 320.0)/320.0 - touches[i].x;
			float nY = (gl_FragCoord.y - 240.0)/240.0 - touches[i].y;
			
			float rd = sqrt(nX * nX + nY * nY);
	
			fc += (1000.*0.01)*0.05*sin(nY*nX*75.0) / (rd*20.0);
		}
	}
	gl_FragColor = vec4(0.2*fc, fc, fc, 1.0);
}
// ]]></script>

</body>

<script type="text/javascript">// <![CDATA[

  var gl;
  var canvas;

  var buffer;

  var shaderSource;
  var vertexShader;
  var fragmentShader;

  var program;

  var mouseX, mouseY;
 


	function init() 
	{
	
		viewX = 640.0;
		viewY = 480.0;
		
		canvas        = document.getElementById('glscreen');
		gl            = canvas.getContext('experimental-webgl');
		canvas.width  = 640;
		canvas.height = 480;
		
		canvas.onmousemove = function(evt) {
			evt.preventDefault();
			mouseX = 2*(evt.pageX / viewX) - 1;
			mouseY = 1 - 2*(evt.pageY / viewY);

			//gl.uniform2f(gl.getUniformLocation(program, "mouse"), mouseX, mouseY);
			var touches3arr = new Float32Array(30);
			touches3arr[0] = mouseX;
			touches3arr[1] = mouseY;
			touches3arr[2] = -1;
			gl.uniform1i(gl.getUniformLocation(program, "touches_length"), 1);
			gl.uniform3fv(gl.getUniformLocation(program, "touches"), touches3arr);
		};
		
		canvas.addEventListener('touchstart', function(event) {
			event.preventDefault();
			//console.log('touchstart');
			touches = event.touches;
		});
		
		canvas.addEventListener('touchmove', function(event) {
			event.preventDefault();
			touches = event.touches;
			var touches3arr = new Float32Array(30);
			for(var i=0; i<touches.length; i++)
			{
				touch = touches[i];
				touches3arr[3*i+0] = 2*(touch.pageX / viewX) - 1;
				touches3arr[3*i+1] = 1 - 2*(touch.pageY / viewY);
				touches3arr[3*i+2] = touch.identifier;
			}
			gl.uniform1i(gl.getUniformLocation(program, "touches_length"), touches.length);
			gl.uniform3fv(gl.getUniformLocation(program, "touches"), touches3arr);
		});
		
		canvas.addEventListener('touchend', function() {
			event.preventDefault();
			//console.log('touchend');
			//touches = event.touches;
		});
		

		gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
		
		setup_shaders();

		setup_vertex(); 
		
		render();
	
	}
 
	function render(time) 
	{
		//gl.uniform1f(gl.getUniformLocation(program, "time"), time);
		
		//gl.clearColor(1.0, 1.0, 1.0, 1.0);
		//gl.clear(gl.COLOR_BUFFER_BIT);
		
		gl.drawArrays(gl.TRIANGLES, 0, 6);
		
		window.requestAnimationFrame(render, canvas);
	}
	
	
	window.onload = init;

// ]]></script>

<script type="text/javascript">// <![CDATA[

	function setup_vertex() 
	{
		buffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
		gl.bufferData(
			gl.ARRAY_BUFFER, 
			new Float32Array([
				-1.0, -1.0, 
				1.0, -1.0, 
				-1.0,  1.0, 
				-1.0,  1.0, 
				1.0, -1.0, 
				1.0,  1.0]), 
			gl.STATIC_DRAW
		);
		
		positionLocation = gl.getAttribLocation(program, "a_position");
		gl.enableVertexAttribArray(positionLocation);

		gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
		
	}

	function setup_shaders()
	{
		shaderScript = document.getElementById("2d-vertex-shader");
		shaderSource = shaderScript.text;
		vertexShader = gl.createShader(gl.VERTEX_SHADER);
		gl.shaderSource(vertexShader, shaderSource);
		gl.compileShader(vertexShader);
		if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
		    alert(gl.getShaderInfoLog(vertexShader));
		}
		
		shaderScript   = document.getElementById("2d-fragment-shader");
		shaderSource   = shaderScript.text;
		fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
		gl.shaderSource(fragmentShader, shaderSource);
		gl.compileShader(fragmentShader);
		if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
		    alert(gl.getShaderInfoLog(fragmentShader));
		}
		
		program = gl.createProgram();
		gl.attachShader(program, vertexShader);
		gl.attachShader(program, fragmentShader);
		gl.linkProgram(program);	
		if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
		    alert("Could not initialise shaders");
		}
		gl.useProgram(program);
	}

// ]]></script>


</html>