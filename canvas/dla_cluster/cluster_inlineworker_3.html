<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>

body { 
    background-color: hsl(30, 25%, 95%);
    margin: 0;
    padding: 0;
    overflow: hidden;
    color: #010;
}
canvas.c {
    border: 2px solid #fb9;
    background-color: #eee;
}

    </style>
</head>
<body onload='Main();'>
  <div class="canvas_box">
    <canvas id='canvas1' width="600" height="800" class="c"></canvas>
  </div>
  <div id="log"></div>

  <script id="worker1" type="javascript/worker">
    // This script won't be parsed by JS engines because its type is javascript/worker.

	var dla = {
		maxPoints: 0, cntPoints: 0,
		xmax: 0, ymax: 0,

		dist_start: 10, dist_end: 50,


		m: [[]], // двумерный массив
		createMatrix: function(initVal) {
			var _m = new Array(this.xmax);
			for (var i = 0; i < this.xmax; i++) 
			{
			    _m[i] = new Array(this.ymax);
				for (var j = 0; j < this.ymax; j++) 
				{
				    _m[i][j] = initVal;
				}
			}
			return _m;
		},


		WorkInit: function(pX,pY) {
	        self.postMessage({log:'WorkInit('+pX+','+pY+')'});
			try
			{
				this.xmax = pX, this.ymax = pY;
				this.maxPoints = pX*pY/6; // эмпирически
	
				this.m = this.createMatrix(-1); // поле для построения
	
				this.m[this.xmax/2][this.ymax/2] = 0; // затравка
	
				return true;
			}
			catch(e)
			{
		        self.postMessage({error:'WorkInit error:' + e.message});
				return false;
			}
		},


		WorkRun: function() {
	        self.postMessage({log:'WorkRun()'});
			try
			{
			    var rmin = this.dist_start;
				var rmax = this.dist_end;
				var rcmax = 0;
				while(this.maxPoints > this.cntPoints)
				{
					var angle = 2 * Math.PI * Math.random();
			        var x = this.xmax/2 + rmin*Math.cos(angle) | 0;
			        var y = this.ymax/2 + rmin*Math.sin(angle) | 0;
			        var rc = rmin;
			        var c = 0; /* 0 значит точка не установлена */
			        while(rc < rmax && c == 0) 
					{
			            var dx = Math.floor(Math.random() * 3) - 1;
			            var dy = Math.floor(Math.random() * 3) - 1;
			            var xnew = x + dx;
			            var ynew = y + dy;
			            rc = Math.sqrt((xnew-this.xmax/2)*(xnew-this.xmax/2)+(ynew-this.ymax/2)*(ynew-this.ymax/2)) | 0;
			            c = this.getPixel(xnew,ynew);
			            if(rc < rmax && c == 0) {
			                x = xnew, y = ynew;
			            }
			        }
			        if(c != 0 && 0<=x && x<this.xmax && 0<=y && y<this.ymax) 
					{
						this.cntPoints++;
			            if(rc > rcmax) { rcmax = rc; }
			            rmin = rcmax + this.dist_start;
			            rmax = rcmax + this.dist_end;
			            
		            	this.m[x][y] = this.cntPoints;
						this.postPixel(x,y);
			        }
					else
					{
						if(c != 0 && (Date.now() - this.prevT) > (10*1000)) // уже долго некуда поставить точку
						{
					        self.postMessage({log:'cntPoints = ' + this.cntPoints});
							this.maxPoints = this.cntPoints;
						}
					}
				}
			}
			catch(e)
			{
		        self.postMessage({error:'WorkRun error:' + e.message});
				return false;
			}
		},
	
		getPixel: function(i,j) {
			if(0<=i && i<this.xmax)
			{
				if(0<=j && j<this.ymax)
				{
					return (this.m[i][j] == -1) ? 0 : 1;
				}
			}
			return 0;
		},

		bufferPoints: [], 
		prevT: Date.now(),
		postPixel: function(px,py) {
			var _point = {x:px,y:py};
			this.bufferPoints.push(_point);
	
			var currT = Date.now();
			var diffT = currT - this.prevT;
			if((diffT > 2*1000) || (diffT > 1000/15 && this.bufferPoints.length > 250))
			{
		        self.postMessage({points:this.bufferPoints});
				this.bufferPoints.length = 0;
				this.prevT = currT;
			}
		},

	};    


	// запуск фонового процесса по сообщению
    self.onmessage = function(e) {
		try
		{
			self.postMessage({log:e.data.startGreeting});
			if(dla.WorkInit(e.data.arrX, e.data.arrY))
			{
				//self.postMessage({log:'after WorkInit()'});
				dla.WorkRun();
				self.postMessage({log:'ЗАВЕРШЕНО WorkRun()'});
			}
		}
		catch(e) { self.postMessage({error:'' + e.message}); }
    };

  </script>

  <script>

	var canvas, context;
	var xmax, ymax, ptCount=0;
	//var setPixel;

	function Main()
	{
		InitCanvas();
		var worker = InitWorker(WorkerMessage);
	    worker.postMessage({startGreeting:"start", arrX: xmax, arrY: ymax});
	}	


	function InitCanvas()
	{
		canvas = document.getElementById('canvas1');
		canvas.oncontextmenu = function() { return false; } 
		context = canvas.getContext('2d');
		//setPixel = WrapSetPixel(context,10,20,30,250);
		xmax = canvas.width;
		ymax = canvas.height;
	}

	function WorkerMessage(e) 
	{
		if(e.data.log)
		{
			log(">" + e.data.log);
		}
		if(e.data.error)
		{
			log("!!! " + e.data.error);
		}
		if(e.data.point && e.data.point.x && e.data.point.y)
		{
			SetPoint(e.data.point.x, e.data.point.y);
		}
		if(e.data.points && e.data.points.length)
		{
			for(var i=0; i<e.data.points.length; i++)
			{
				SetPoint(e.data.points[i].x, e.data.points[i].y);
			}
		}
    }

	var begColor = Math.round(360 * Math.random()), colorScale = 15 + Math.round(65 * Math.random());

	function SetPoint(x,y)
	{
		//log("SetPoint("+x+","+y+")");
		var cx = x;
		var cy = y;
		//setPixel(cx,cy);
		ptCount++;
		var color = "hsla("+((begColor+ptCount/colorScale) % 360)+",75%,30%,"+(200/255)+")";
		context.fillStyle = color;
		context.fillRect(cx,cy,1,1);
	}

  </script>

  <script>

	function InitWorker(workerMsg, workerError)
	{
	    var blob = new Blob([
	      document.querySelector('#worker1').textContent
	    ], { type: "text/javascript" });

	    var worker = new Worker(window.URL.createObjectURL(blob));

	    worker.onmessage = workerMsg;

		if(workerError) { worker.onerror = workerError; } else { worker.onerror = function (e) { log("Error: " + e.message); }; }

		return worker;
	}


    function log(msg) {
      // Use a fragment: browser will only render/reflow once.
      var fragment = document.createDocumentFragment();
      fragment.appendChild(document.createTextNode(msg));
      fragment.appendChild(document.createElement('br'));

      document.querySelector("#log").appendChild(fragment);
    }


	function WrapSetPixel(myContext, r, g, b, a)
	{
		var id = myContext.createImageData(1,1);
		var d  = id.data;                        
		d[0] = r; d[1] = g; d[2] = b; d[3] = a/255;
		return function(x, y) { 
			myContext.putImageData(id, x, y); 
		};  	
	}

  </script>

</body>
</html>