<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>

body { 
    background-color: hsl(30, 25%, 95%);
    margin: 0;
    padding: 0;
    overflow: hidden;
    color: #010;
}
canvas.c {
    border: 2px solid #fb9;
    background-color: #eee;
}

    </style>
</head>
<body onload='Main();'>
  <div class="canvas_box">
    <canvas id='canvas1' width="600" height="800" class="c"></canvas>
  </div>
  <div id="log"></div>

  <script id="worker1" type="javascript/worker">
    // This script won't be parsed by JS engines because its type is javascript/worker.
    
	var maxPoints = 0, cntPoints = 1;
	var m; // двумерный массив

	var xmax,ymax;
	var dist_start = 10, dist_end = 50;
	//var dist_start = 80, dist_end = 110;
	var rmin, rmax, rcmax, c;


	function WorkInit(pX,pY)
	{
        self.postMessage({log:'WorkInit('+pX+','+pY+')'});
		try
		{
			xmax = pX, ymax = pY;
			maxPoints = pX*pY/6; // эмпирически

			m = createMatrix(xmax,ymax,-1); // поле для построения

			m[xmax/2][ymax/2] = 0; // затравка
		    rmin = dist_start, rmax = dist_end, rcmax = 0;

			return true;
		}
		catch(e)
		{
	        self.postMessage({error:'WorkInit error:' + e.message});
			return false;
		}
	}

	function WorkRun()
	{
        self.postMessage({log:'WorkRun()'});
		try
		{
			while(maxPoints > cntPoints)
			{
				var angle = 2 * Math.PI * Math.random();
		        var x = xmax/2 + rmin*Math.cos(angle) | 0;
		        var y = ymax/2 + rmin*Math.sin(angle) | 0;
		        var rc = rmin;
		        c = 0; /* 0 значит точка не установлена */
		        while(rc < rmax && c == 0) 
				{
		            var dx = Math.floor(Math.random() * 3) - 1;
		            var dy = Math.floor(Math.random() * 3) - 1;
		            var xnew = x + dx;
		            var ynew = y + dy;
		            rc = Math.sqrt((xnew-xmax/2)*(xnew-xmax/2)+(ynew-ymax/2)*(ynew-ymax/2)) | 0;
		            c = getPixel(xnew,ynew);
		            if(rc < rmax && c == 0) {
		                x = xnew, y = ynew;
		            }
		        }
		        if(c != 0 && 0<=x && x<xmax && 0<=y && y<ymax) 
				{
					cntPoints++;
		            if(rc > rcmax) { rcmax = rc; }
		            rmin = rcmax + dist_start;
		            rmax = rcmax + dist_end;
		            
	            	m[x][y] = cntPoints;
					postPixel(x,y);
		        }
				else
				{
					if(c != 0 && (Date.now() - prevT) > (10*1000)) // уже долго некуда поставить точку
					{
				        self.postMessage({log:'cntPoints = ' + cntPoints});
						maxPoints = cntPoints;
					}
				}
			}
		}
		catch(e)
		{
	        self.postMessage({error:'WorkRun error:' + e.message});
			return false;
		}
	}

	var bufferPoints = [], prevT = Date.now();
	function postPixel(px,py)
	{
		var _point = {x:px,y:py};
		bufferPoints.push(_point);

		var currT = Date.now();
		var diffT = currT - prevT;
		if((diffT > 2*1000) || (diffT > 1000/15 && bufferPoints.length > 250))
		{
	        self.postMessage({points:bufferPoints});
			bufferPoints.length = 0;
			prevT = currT;
		}
	}

	function getPixel(i,j)
	{
		if(0<=i && i<xmax)
		{
			if(0<=j && j<ymax)
			{
				return (m[i][j] == -1) ? 0 : 1;
			}
		}
		return 0;
	}
	
	function createMatrix(xmax,ymax,initVal)
	{
		var m = new Array(xmax);
		for (var i = 0; i < xmax; i++) 
		{
		    m[i] = new Array(ymax);
			for (var j = 0; j < ymax; j++) 
			{
			    m[i][j] = initVal;
			}
		}
		return m;
	}

	// запуск фонового процесса по сообщению
    self.onmessage = function(e) {
		try
		{
			self.postMessage({log:e.data.startGreeting});
			if(WorkInit(e.data.arrX, e.data.arrY))
			{
				//self.postMessage({log:'after WorkInit()'});
				WorkRun();
				self.postMessage({log:'ЗАВЕРШЕНО WorkRun()'});
			}
		}
		catch(e) { self.postMessage({error:'' + e.message}); }
    };

  </script>

  <script>

	var canvas, context;
	var xmax, ymax, ptCount=0;
	//var setPixel;

	function Main()
	{
		InitCanvas();
		var worker = InitWorker(WorkerMessage);
	    worker.postMessage({startGreeting:"start", arrX: xmax, arrY: ymax});
	}	


	function InitCanvas()
	{
		canvas = document.getElementById('canvas1');
		canvas.oncontextmenu = function() { return false; } 
		context = canvas.getContext('2d');
		//setPixel = WrapSetPixel(context,10,20,30,250);
		xmax = canvas.width;
		ymax = canvas.height;
	}

	function WorkerMessage(e) 
	{
		if(e.data.log)
		{
			log(">" + e.data.log);
		}
		if(e.data.error)
		{
			log("!!! " + e.data.error);
		}
		if(e.data.point && e.data.point.x && e.data.point.y)
		{
			SetPoint(e.data.point.x, e.data.point.y);
		}
		if(e.data.points && e.data.points.length)
		{
			for(var i=0; i<e.data.points.length; i++)
			{
				SetPoint(e.data.points[i].x, e.data.points[i].y);
			}
		}
    }

	var begColor = Math.round(360 * Math.random()), colorScale = 15 + Math.round(65 * Math.random());

	function SetPoint(x,y)
	{
		//log("SetPoint("+x+","+y+")");
		var cx = x;
		var cy = y;
		//setPixel(cx,cy);
		ptCount++;
		var color = "hsla("+((begColor+ptCount/colorScale) % 360)+",75%,30%,"+(200/255)+")";
		context.fillStyle = color;
		context.fillRect(cx,cy,1,1);
	}

  </script>

  <script>

	function InitWorker(workerMsg, workerError)
	{
	    var blob = new Blob([
	      document.querySelector('#worker1').textContent
	    ], { type: "text/javascript" });

	    var worker = new Worker(window.URL.createObjectURL(blob));

	    worker.onmessage = workerMsg;

		if(workerError) { worker.onerror = workerError; } else { worker.onerror = function (e) { log("Error: " + e); }; }

		return worker;
	}


    function log(msg) {
      // Use a fragment: browser will only render/reflow once.
      var fragment = document.createDocumentFragment();
      fragment.appendChild(document.createTextNode(msg));
      fragment.appendChild(document.createElement('br'));

      document.querySelector("#log").appendChild(fragment);
    }


	function WrapSetPixel(myContext, r, g, b, a)
	{
		var id = myContext.createImageData(1,1);
		var d  = id.data;                        
		d[0] = r; d[1] = g; d[2] = b; d[3] = a/255;
		return function(x, y) { 
			myContext.putImageData(id, x, y); 
		};  	
	}

  </script>

</body>
</html>